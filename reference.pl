#!/usr/bin/perl -w
use strict;


# 引用的用途
	
	# 创建复杂的数据结构，将数据结构当作标量处理
	# 
	# 向子程序传递数组和哈希表

	# 获取引用内的数据第一步是要 获得 反引用

# 直接引用
# 使用前缀 $ @ % & 来反引用

	my $a = 5;
	my $ref = \$a;
	print $$ref."\n";



# 符号引用 (不推荐)
	# 符号引用并不保存数据项的地址和类型，而是保存数据型的名称（软引用）
	
	my $b = 5;
	my $variname = "b";
	print "$$variname";



# 使用箭头运算符反引用 ----------- 直接处理引用
	
	my @a = (1 .. 3);
	my $aref = \@a;

	print @{$a}[0];    # 前缀引用
	
	print $aref -> [0]  # 箭头引用

	# 箭头运算符提供了直接处理引用，而不需要再次创建正在引用的数组或者哈希表的方法


# 匿名数组、哈希表和子程序
	# perl引用的强大功能之一就是可以对数组、哈希表和子程序的引用，而不是名称来创建那些结构
	#
	# 需要存储的是对它们的引用，而不是名称
	

	$arref = [1,2,3];  # 仅仅是对新数组的引用，而不是新数组的名称

	print $arref -> [0];



# 对表的引用
	
	# 常规的我们知道对标准数据项的引用，如标量和数组等，但也可以建立对表的直接引用，表并没有设置数据类型
	
	# 下面这两行代码完成相同的工作
	
	@ref = \($a,$b,$c);
	@ref = (\$a,\$b,\$c);

		# 诸如 \@ref这样的表达式也同样，它返回对 @ref中内容引用的列表，而不是对 @ref 本身的引用，与类似 \(%ref) 一样
	
	
	# 在使用表引用时要注意下面两种情况

	$ref = \(2,3,4);  # 得到的其实是表中最后一个标量的引用，即这是标量引用
	
	print ${$ref}."\n";   # print 4


	$ref = \(2 .. 4);   # 对范围运算符创建的表的引用实际上会产生数组引用，不是标量引用

	print "@{$ref}";



# 创建匿名数组的引用
	
	# 匿名数组构成符 [] 返回对匿名数组的引用
	
	$a = [1 .. 3];
	print $a -> [1];


	# 匿名数组构成符建立数组的副本
	
	@a = (1 .. 3);
	my $ref = pop @{[@a]}  # 原始数组不会发生改变

	
	# 匿名数组构成符也可以创建表引用
	
	my $ref = [qw/now is the time/];

	print "@{$ref}";


	# 如果希望使用 $#array 语法来找匿名数组的长度，只需要用 $#ref即可（数组引用等价与数组内每一个元素的引用）

	my $ref = [1 .. 3];

	for (my $i = 0; $i < $#ref + 1; $i++) {
	
		... ;
	}

	
# 创建匿名哈希的引用 ---- {}  (略)
	



# 创建对匿名子程序的引用 -------  sub {}
	
	# 可以用匿名子程序创建无名称子程序的引用
	
	my $code = sub {print "hello\n"};   # 结尾必须加入分号，而对普通的子程序定义不需要分号

	&{$code};       # 获取反引用

	# 向匿名子程序传递参数
	
	my $code = sub {print shift};
	
	&{$code}("hello\n");   # 前缀引用
	
	$code -> ("hello\n");  # 箭头运算符引用


# 用 ref 运算符确定引用类型
	


# 从函数模板创建函数
	
	sub code {
		my $first = shfit;
		return sub {
			my $first1 = shift;
			print "$first\t$first1\n";
		}
	}
